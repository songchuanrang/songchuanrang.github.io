---
title: 设计模式
date: 2023/10/10 15:47:17
comments: true
---

# 设计模式

### 创建型模式

1. 工厂设计模式
   工厂方法模式在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。工厂方法将创建产品的代码与实际使用产品的代码分离，  从而能在不影响其他代码的情况下扩展产品创建部分代码。
2. 抽象工厂模式
   抽象工厂模式能创建一系列相关的对象，而无需指定其具体类。
3. 生成器模式
   生成器模式使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。
4. 原型模式
   原型模式为客户端代码提供一个通用接口，客户端代码可通过这一接口与所有实现了克隆的对象进行交互，它也使得客户端代码与其所克隆的对象具体类独立开来。
5. 单例模式
   单例模式让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

### 结构型模式

1.  适配器模式
    适配器模式能使接口不兼容的对象能够相互合作。
2.  桥接模式
    桥接模式可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。
    桥接建议将每个维度抽取为独立的类层次。初始类将相关工作委派给属于对应类层次的对象，无需自己完成所有工作。
3.  组合模式
    组合模式可以将对象组合成树状结构，并且能像使用独立对象一样使用它们。组合模式为你提供了两种共享公共接口的基本元素类型：  简单叶节点和复杂容器。  容器中可以包含叶节点和其他容器。  这使得你可以构建树状嵌套递归对象结构。组合模式中定义的所有元素共用同一个接口。  在这一接口的帮助下，  客户端不必在意其所使用的对象的具体类。
4.  装饰模式
    装饰模式允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。
5.  外观模式
    外观模式能为程序库、框架或其他复杂类提供一个简单的接口。
6.  享元模式（缓存模式）
    享元模式摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。
7.  代理模式
    代理模式让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

### 行为模式

1. 责任链模式
   责任链模式允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。
2. 命令模式
   命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。
3. 迭代器模式
   迭代器模式让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。
4. 中介者模式
   中介者模式能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。
5. 备忘录模式
   备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。
6. 观察者模式
   观察者模式允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。
7. 状态模式
   状态模式让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。
8. 策略模式
   策略模式能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。
9. 模板方法模式
   模板方法模式在超类中定义了一个算法的框架，  允许子类在不修改结构的情况下重写算法的特定步骤。
10. 访问者模式
    访问者模式能将算法与其所作用的对象隔离开来。

## 模式对比

桥接模式通常会于开发前期进行设计，  使你能够将程序的各个部分独立开来以便开发。  另一方面，  适配器模式通常在已有程序中使用，  让相互不兼容的类能很好地合作。
适配器可以对已有对象的接口进行修改，  装饰模式则能在不改变对象接口的前提下强化对象功能。  此外，  装饰还支持递归组合，  适配器则无法实现。
适配器能为被封装对象提供不同的接口，  代理模式能为对象提供相同的接口，  装饰则能为对象提供加强的接口。
外观模式为现有对象定义了一个新接口，  适配器则会试图运用已有的接口。  适配器通常只封装一个对象，  外观通常会作用于整个对象子系统上。
桥接、  状态模式和策略模式  （在某种程度上包括适配器）  模式的接口非常相似。  实际上，  它们都基于组合模式——即将工作委派给其他对象，  不过也各自解决了不同的问题。  模式并不只是以特定方式组织代码的配方，  你还可以使用它们来和其他开发者讨论模式所解决的问题。
